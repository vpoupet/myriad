<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>A Linear Acceleration for all Neighborhoods on 2D Cellular Automata</title>
    <link rel="stylesheet" href="../../css/slides.css">
    <link rel="stylesheet" href="../../css/myriad.css">
    <link rel="stylesheet" href="acclin.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>\(
    \newcommand{\TR}{\operatorname{TR}}
    \renewcommand{\epsilon}{\varepsilon}
    \newcommand{\ZZ}{\mathbb{Z}}
    \newcommand{\NN}{\mathbb{N}}
    \newcommand{\QQ}{\mathbb{Q}}
    \newcommand{\RR}{\mathbb{R}}
    \newcommand{\ACA}{\mathcal{A}}
    \newcommand{\ACQ}{\mathcal{Q}}
    \)
  </head>
  <body>
    <section class="title">
      <h1>A Linear Acceleration for all Neighborhoods on 2D Cellular Automata</h1>
      <div class="context">Séminaire ALGO</div>
      <div class="author">Anaël Grandjean and <span class="underline">Victor Poupet</span></div>
      <time datetime="2015-06-23">June 23, 2015</time>
    </section>
    <section class="section">
      <h1>Definitions</h1>
    </section>
    <section class="split">
      <h1>Cellular Automata</h1>
      <div class="side"><img class="only" src="figures/2DCA-0.svg" data-step="0"><img class="only" src="figures/2DCA-1.svg"><img class="only" src="figures/2DCA-2.svg"><img class="only" src="figures/2DCA-3.svg"><img class="only" src="figures/2DCA-4.svg"></div>
      <div class="side">
        <p>2-dimensional cellular automata (2DCA) \(\ACA = (\ACQ, V, \delta)\)&nbsp;:</p>
        <ul>
          <li class="uncover" data-start="1">\(\ACQ\) is a finite set (<em>states</em>)</li>
          <li class="uncover">\(V\) is a finite subset of \(\ZZ^2\), \(0\in V\) (<em>neighborhood</em>)</li>
          <li class="uncover">\(\delta:\ACQ^{V}\rightarrow \ACQ\) (<em>local function</em>)</li>
        </ul><br>
        <p class="uncover">global function \(\Delta: \ACQ^{\ZZ^2}\rightarrow \ACQ^{\ZZ^2}\)</p>
      </div>
    </section>
    <section class="split">
      <h1>Language Recognition</h1>
      <div class="side">
        <div class="center"><img src="figures/languageRecognition.svg" style="width: 80%"></div>
      </div>
      <div class="side">
        <p>
          Languages of rectangular pictures in\[\Sigma^{**} = \bigcup_{n, m} \Sigma^{(n, m)}\]</p>
        <p class="uncover">We consider 2DCA such that</p>
        <ul class="uncover" data-start="1">
          <li>\(\Sigma\subseteq \ACQ\)</li>
          <li>\(\#\in \ACQ\) is a <em>quiescent</em> state</li>
          <li>\(\ACQ_{\operatorname{acc}} \subseteq \ACQ\) is a set of <em>accepting states</em></li>
        </ul><br>
        <ul class="uncover">
          <li>Input is parallel</li>
          <li>Recognition on the origin cell</li>
        </ul>
        <p class="uncover">
          Time complexity is as expected\[f: \NN^2 \rightarrow \NN\]</p>
      </div>
    </section>
    <section class="split">
      <h1>Neighborhoods</h1>
      <div class="side"><img class="only" src="figures/iterations-01.svg" data-step="0"><img class="only" src="figures/iterations-02.svg"><img class="only" src="figures/iterations-03.svg"><img class="only" src="figures/iterations-04.svg"><img class="only" src="figures/iterations-05.svg" data-start="4"></div>
      <div class="side">
        <div class="box">
          <div class="box-title">Def. (Iterations)</div>
          <div class="box-content">
            <div class="tight">
              \begin{align*}
              V^0 &= \{0\}\\
              V^{n+1} &= V + V^n\\
              &= \{x, y \ |\ x \in V, y\in V^n\}
              \end{align*}
            </div>
          </div>
        </div>
        <p>\(V^n\) is the set of cells that the origin can <em>see</em> in \(n\) time steps.</p>
        <div class="box uncover" data-start="4">
          <div class="box-title">Def. (Scalar Product)</div>
          <div class="box-content">
            <div class="tight">
              \begin{align*}
              kV = \{k.x \ |\ x \in V\}
              \end{align*}
            </div>
          </div>
        </div>
        <div class="box uncover">
          <div class="box-title">Def.</div>
          <div class="box-content">
            <div class="tight">
              A neighborhood \(V\) is <em>complete</em> if
              \[\bigcup_{n\in\NN}V^n = \ZZ^2\]
            </div>
          </div>
        </div>
      </div>
    </section>
    <section class="split">
      <h1>Convex Hull</h1>
      <div class="side"><img class="only" src="figures/convexHull1.svg" data-step="0"><img class="only" src="figures/convexHull2.svg" data-start="1" data-end="2"><img class="only" src="figures/convexHull3.svg" data-step="3"></div>
      <div class="side">
        <div class="only" data-end="1">
          <div class="box">
            <div class="box-title">Def.</div>
            <div class="box-content">
              <p>The convex hull of a neighborhood \(V\) is the smallest convex polygon (in \(\RR^2\)) containing \(V\).</p>
            </div>
          </div><br>
          <p>The vertices of the convex hull are elements of \(V\)</p>
        </div>
        <div class="only" data-start="2">
          <div class="box">
            <div class="box-title">Prop.</div>
            <div class="box-content">
              <p>If a neighborhood is complete, its convex hull contains an open ball around the origin.</p>
            </div>
          </div><br>
          <div class="box uncover">
            <div class="box-title">Prop.</div>
            <div class="box-content tight">
              \(\forall x\in\QQ^2\), if \(x\) is on the border of the convex hull of \(V\) then
              \[x = \lambda u + (1-\lambda)v\]
              with \(u, v\in V\) and \(\lambda\in [0, 1]\cap \QQ\)
            </div>
          </div>
        </div>
      </div>
    </section>
    <section class="single">
      <h1>Real Time</h1>
      <div class="box">
        <div class="box-title">Definition</div>
        <div class="box-content">
          <p>
            The real time function corresponding to a given neighborhood \(V\) is defined as\begin{align*}
            \TR_V: \NN^2 &\rightarrow \NN\\
            (n, m) &\mapsto \min\{t \ |\ n\times m\subseteq V^t\}
            \end{align*}
          </p>
          <div style="width: 100%; height: 0"></div>
        </div>
      </div><br>
      <ul class="uncover">
        <li>Larger neighborhoods have less real time</li>
        <li>
          Complete neighborhoods with coinciding convex hulls on the positive quarter have same real time up to anadditive constant</li>
      </ul>
    </section>
    <section class="section">
      <h1>Linear Acceleration<br> on the<br>Moore Neighborhood</h1>
    </section>
    <section class="single">
      <h1>On the Moore Neighborhood</h1>
      <div class="box">
        <div class="box-title">Theorem</div>
        <div class="box-content">
          <p>
            For any \(\epsilon > 0\), any language recognized in time \((\TR + f)\) by a 2DCA working on the Mooreneighborhood can be recognized in time
            \[\TR + \lceil\epsilon f\rceil\]
          </p>
        </div>
      </div><br>
      <div class="uncover">
        <p>Proof&nbsp;:</p>
        <ul>
          <li>Compress the input by a factor \(k \geq \epsilon^{-1}\)<span style="float: right">\(\frac{k-1}{k}\TR\) steps</span></li>
          <li>Simulate the original automaton, \(k\) steps at a time<span style="float: right">\(\frac{1}{k}(\TR + f)\) steps</span></li>
        </ul>
      </div>
    </section>
    <section class="split">
      <h1>Compression</h1>
      <div class="side center">
        <div style="width: 80%"><img class="only" src="figures/compression1.svg" data-step="0"><img class="only" src="figures/compression2.svg"><img class="only" src="figures/compression3.svg"><img class="only" src="figures/compression4.svg"><img class="only" src="figures/compression5.svg"><img class="only" src="figures/compression6.svg"></div>
      </div>
      <div class="side">
        <p>A cell of the new automaton can contain up to \(k^2\) states of the original CA.</p>
        <ul>
          <li>Send initial data towards the origin</li>
          <li>When a cell contains \(k\times k\) initial states it is full</li>
        </ul>
      </div>
    </section>
    <section class="split">
      <h1>Simulation</h1>
      <div class="side center">
        <div style="width: 80%"><img src="figures/simulation.svg"></div>
      </div>
      <div class="side">
        <p>Proof by induction</p>
        <ul>
          <li>A cell needs to see \(V^k + c\) for each \(c\) it contains</li>
          <li>The needed information is held by its immediate neighbors</li>
          <li>Cells can compute \(k\) steps of the original automaton on each state they hold</li>
        </ul>
      </div>
    </section>
    <section class="split">
      <h1>Self Synchronization</h1>
      <div class="side center"><img src="figures/selfsyncNeighborhood.svg" style="width: 60%"><br><img class="only" src="figures/selfsync1.svg" style="width: 80%" data-end="2"><img class="only" src="figures/selfsync2.svg" style="width: 80%" data-step="3"><img class="only" src="figures/selfsync3.svg" style="width: 80%"><img class="only" src="figures/selfsync4.svg" style="width: 80%"><img class="only" src="figures/selfsync5.svg" style="width: 80%"><img class="only" src="figures/selfsync6.svg" style="width: 80%"><img class="only" src="figures/selfsync7.svg" style="width: 80%"></div>
      <div class="side">
        <p><strong>Problem&nbsp;:</strong> cells do not complete compression at the same time</p>
        <p><strong>Solution&nbsp;:</strong> compute new states as soon as relevant information is available.</p>
        <div class="box uncover" data-start="1">
          <div class="box-title">Claim</div>
          <div class="box-content">
            <p>All cells are at least as fast as if they all started at the same time as the last.</p>
          </div>
        </div>
        <ul class="uncover">
          <li>assume \(V\) is complete</li>
          <li>time difference between neighbor cells is bounded by \(k\) such that \(-V\subseteq V^k\)</li>
          <li>cells know their simulated time mod. \((2k+1)\) and their last \(k\) states</li>
          <li>the last cell never waits</li>
        </ul>
      </div>
    </section>
    <section class="section">
      <h1>Linear Acceleration</h1>
    </section>
    <section class="single">
      <h1>Main Theorem</h1>
      <div class="box">
        <div class="box-title">Theorem</div>
        <div class="box-content">
          For any complete neighborhood \(V\) and any \(\epsilon > 0\), any language recognized in time \((\TR + f)\) by a
          2DCA working on \(V\) can be recognized in time
          \[(1+\epsilon)\TR + \epsilon f\]
        </div>
      </div><br>
      <div class="uncover">
        <p>Proof&nbsp;:</p>
        <ul>
          <li>Compress the input by a factor \(k \geq \epsilon^{-1}\)</li>
          <li>Simulate the original automaton, \(k\) steps at a time</li>
        </ul>
      </div>
    </section>
    <section class="split">
      <h1>Simulation</h1>
      <div class="side center"><img src="figures/simulationGeneral.svg" style="width: 80%"></div>
      <div class="side">
        <p><strong>Problem&nbsp;:</strong> After compression, a cell sees \(kV + c\) for the information it holds, not \(V^k + c\)</p>
        <p class="uncover"><strong>Solution&nbsp;:</strong> Gather more information&nbsp;!</p><br>
        <div class="uncover">
          <ul>
            <li>\(m = (k-1)|V| - k + 1\)</li>
            <li>\(V^{m+k} \subseteq V^m + kV\)</li>
            <li>Cells gather the initial states in \(V^m + c\) for each \(c\) that was compressed to it</li>
            <li>Bounded time loss</li>
          </ul><br>
          <p>At each step, cells can compute \(k\) steps of the original automaton for each of the information they hold.</p>
        </div>
      </div>
    </section>
    <section class="single">
      <h1>Compression</h1>
      <p><strong>Difficulty&nbsp;:</strong> Optimal path towards the origin depends on the ratio \(\frac m n\)</p>
      <ul>
        <li>Optimal path is a combination of two vertices of the convex hull</li>
        <li>Moore neighborhood&nbsp;: combination of diagonal and horizontal/vertical</li>
      </ul><br>
      <p><strong>Idea&nbsp;:</strong></p>
      <ul>
        <li>Compression can be done optimally on "Moore-like" neighborhoods</li>
        <li>Break other neighborhoods into Moore-like</li>
        <li>Perform "close-to-optimal" compression</li>
      </ul>
    </section>
    <section class="split">
      <h1>Moore-Like Neighborhoods</h1>
      <div class="side center"><img src="figures/mooreLike.svg" style="width:80%"></div>
      <div class="side">
        <p>Defintion: see picture.</p>
        <div class="box">
          <div class="box-title">Claim</div>
          <div class="box-content">
            <p>
              A Moore-like neighborhood can perform a compression of the input by a factor \((k+1)\) in time\[\frac{k}{k+1}\TR\]</p>
          </div>
        </div><br>
        <p class="uncover">Proof&nbsp;: Same as for the Moore neighborhood</p>
      </div>
    </section>
    <section class="split">
      <h1>Fixed Ratio</h1>
      <div class="side"><img class="only" src="figures/fixedRatio.svg" data-step="0"><img class="only" src="figures/fixedRatioBis.svg"></div>
      <div class="side">
        <p>
          For input words with a specific ratio \(\rho\), the complete neighborhood \(V\) can behave as a Moore-likeneighborhood \(V'\)</p>
        <ul class="uncover" data-start="1">
          <li>because \(V\) is complete, it contains a scaled down version of the rectangle in the negative quarter</li>
          <li>\(V\) and \(V'\) have same real time function for words of ratio \(\rho\)</li>
        </ul>
      </div>
    </section>
    <section class="split">
      <h1>Approximate Ratio</h1>
      <div class="side"><img class="only" src="figures/fixedRatioEpsilon.svg" data-step="0"><img class="only" src="figures/epsilonArgument.svg"></div>
      <div class="side">
        <ul>
          <li>Pick \(\epsilon>0\)</li>
          <li>Consider the set \(M_\epsilon\) of Moore-like neighborhoods spaced by \(\epsilon\)</li>
        </ul><br>
        <p>
          For any input picture, there is \(V'\in M_\epsilon\) that can compress it by \(k+1\) in time\[(1+\epsilon')\frac{k}{k+1}\TR_{V}\]</p>
      </div>
    </section>
    <section class="single">
      <h1>Summary</h1>
      <ul>
        <li>Pick a small enough \(\epsilon\) and a large enough \(k\)</li>
        <li>Compress input by \((k+1)\) on all Moore-like neighborhoods in \(M_\epsilon\)<span style="float: right">\((1+\epsilon)\frac{k}{k+1}\TR\)</span></li>
        <li>Use self synchronization when input is compressed</li>
        <li>Gather extra information on compressed cells<span style="float: right">constant time</span></li>
        <li>Run accelerated simulation of original automaton<span style="float: right">\(\frac{\TR+f}{k+1}\)</span></li>
      </ul><br>
      <div class="center">
        <div>Total time&nbsp;: \((1+\epsilon)\TR + \epsilon f\)</div>
      </div>
    </section>
    <section class="no-page-counter"><img src="figures/tableau.png" style="width: 100%; height: 100%"></section>
    <script src="../../js/slides.js"></script>
    <script src="../../js/myriad.js"></script>
  </body>
</html>