extends ../../slides.pug

block preamble
  -
    root = "../../slides";
    language = "en";
    context = "Embedded Systems";
    title = "An Introduction to<br>iOS Development";
    author = "Victor Poupet";
    date = "2018-07";

append header
  link(rel="stylesheet" href="highlight.css")
  style
    | pre code { font-size: calc(6 * var(--pt)); }

block document
  section.blank.no-page-counter
    img(src="figures/Montpellier.jpg" style="height: 100%; width: 100%")

  .section-counter
  section.section
    h1 A Word About iOS

  section
    h1 iOS
    .side
      .center
        img(src="figures/screenshot.jpg" style="width: 80%")
    .side
      ul
        li released in 2007 (with the first generation iPhone)
        li Multi-touch interface (almost button-less)
        li Gesture recognition (swipe, pinch, etc.)
        li Somewhat based on Mac OSX
        li Core Foundation and Foundation frameworks
        li Cocoa touch instead of Cocoa
        li Darwin (Unix-like system)

  section
    h1 Version History
    .side
      img(src="figures/iOS_versions.jpg" style="width: 100%")
    .side
      ul
        li 2007 - iPhone OS 1
        li 2008 - iPhone OS 2 (iPhone SDK, App Store, 3rd party apps)
        li 2009 - iPhone OS 3 (iPad)
        li 2010 - iOS 4 (limited multitasking)
        li 2011 - iOS 5 (iCloud)
        li 2012 - iOS 6
        li 2013 - iOS 7 (extended multitasking)
        li 2014 - iOS 8 (Swift, Metal)
        li 2015 - iOS 9 (split view)
        li 2016 - iOS 10 (Siri, 3D touch)
        li 2017 - iOS 11 (ARKit, Files, more multitasking)

  section
    h1 Fragmentation
    .side
      ul
        li iOS runs on a limited number of devices (similar architecture, similar iterface)
        li Most devices run the latest version of iOS
        li OS, hardware and SDK are developped by the same company
    .side
      ul
        li Devices have varying screen size and resolution
        li Some features are not available to all devices (multitasking, Siri, camera, etc.)
        li Two main device families&nbsp;:
          ul
            li iPhone
            li iPad

  section
    h1 Distribution
    p The only officially accepted way to add apps to an iOS terminal is to use Apple's <em>App Store</em>

    ul
      li Apple has total control over which apps are accepted on the store
        ul
          li delay between submission and availability
          li Apple guidelines are strict and sometimes difficult to match
          li guarantees a minimal quality of apps
      li developper license (99$ / year) necessary to submit an app
      li free developper account sufficient to develop and install apps on personal devices
      li developpers receive 70% of the price of the sold app

  section
    h1 About this Lecture
    p iOS development is a vast topic
    ul
      li many elements cannot be addressed in this lecture (including important ones)
      li even with more time, one never fully knows all about iOS programming
        ul
          li hundreds of existing classes
          li thousands of methods and attributes
          li best way to learn is to look for examples, ask questions and read the documentation
      li the API, SDK and language evolve quickly
        ul
          li examples and discussions on the Internet are already outdated
          li this lecture is also already outdated
      li most elements are interconnected
        ul
          li no natural order to present things
          li examples require to use some elements before explaining them

  .section-counter
  section.section
    h1 Mobile Development

  section
    h1 Generalities
    p Developping for an embedded system
    ul
      li cross-compiling
      li stronger contraints
        ul
          li memory
          li energy
          li CPU
    br
    p Conception based on user interface
      ul
        li Model-View-Controller architecture
        li Reactive programming
        li Event-based programming

  section
    h1 Mobile Terminals
    .side
      img(src="figures/iphone_ipad.jpg" style="width: 100%")
    .side
      ul
        li Miniature computer
        li Embedded system
          ul
            li limited resources
        li Reactive system
          ul
            li based on user interface
        li Smartphone vs.Tablet
          ul
            li screen size is different
            li phone calls
            li most of the rest is identical

  section
    h1 Architecture
    .side
      img(src="figures/appleA10.png" style="width: 100%")
    .side
      p Processor
      ul
        li ARM (designed by Apple)
      br
      p Storage
      ul
        li Flash memory
      br
      p Other hardware
      ul
        li Network
        li Accelerometer, gyroscope
        li GPS location
        li Camera
        li etc.

  section
    h1 iOS vs. Android
    .side
      img(
      src="figures/iOS.png"
      style="position: absolute;" +
      "top: calc(12 * var(--mm));" +
      "left: calc(32 * var(--mm));" +
      "width: 20%")
      p
        strong Developper
      ul
        li Apple

      br
      p
        strong Programming language
      ul
        li Swift and/or Objective C
        li some C and C++

      br
      p
        strong Development environment
      ul
        li XCode

      br
      p
        strong Development kit
      ul
        li iOS SDK

    .side
      img(
      src="figures/android.jpg"
      style="position: absolute;" +
      "top: calc(8 * var(--mm));" +
      "right: calc(5 * var(--mm));" +
      "width: 15%")

      p
        strong Developper
      ul
        li Google

      br
      p
        strong Programming language
      ul
        li Java
        li some C++
        li (Kotlin, possibly Swift in the future)

      br
      p
        strong Development environment
      ul
        li Eclipse

      br
      p
        strong Development kit
      ul
        li Android SDK

  section
    h1 Cross-Compilation
    img(src="figures/cross_compilation.svg" style="width:100%")

  section
    h1 Constraints
    p Limited resources
    ul
      li Memory
        ul
          li Beware of memory leaks
          li Java (Android): garbage collector
          li Swift / Objective C (iOS): Automatic Reference Counting (ARC)
      li Energy
        ul
          li Some activities are very demanding (GPS, camera, etc.)
          li Avoid inefficient algorithms (CPU drains battery)
    br
    p Handle urgent events
    ul
      li Low memory alert
      li Low battery alert
      li Phone call interruption

  section
    h1 Other Constraints
    strong User interface
    ul
      li Simple and convenient to use
      li Should be reactive
      li Should fit with the OS and other apps ("look and feel")

    strong Fiability
    ul
      li Avoid errors and crashing (no error handling when app crashes)

    strong Security
    ul
      li Device holds sensitive personal data
      li Apps each have their own files directory and run in a sandbox (iOS only)

    strong Speed
    ul
      li App should work on slower devices, with other apps using resources

  section
    h1 First Example
    p &rarr; Writing the first app in XCode&nbsp;: <em>Greeting</em>

  section
    h1 Workflow
    p Mobile development is built around the user interface (screen):
    br
    ul
      li Design <em>Graphical User Interface</em> (GUI)
      li Define and handle <em>events</em>

  section
    h1 Events
    .side
      p Interruption
      ul
        li stops execution and jumps to a specific address
          ul
            li low level
            li hardware exceptions
      br
      p Examples&nbsp;:
      ul
        li division by zero
        li reset button
        li process interruption
    .side
      p Event
      ul
        li stops execution and runs a procedure
          ul
            li higher level
            li handled by OS interface
      br
      p Examples&nbsp;:
      ul
        li click a button
        li move the cursor
        li thread finishes a computation

  section
    h1 Call-back
    p Events are handled by "call-backs"
    ul
      li Enable an event
        ul
          li associate a routing procedure to an existing event
      li Disable an event
        ul
          li remove association with procedure (event will not trigger the procedure if it happens)
      li Wait for an event
    p If an event is not enabled (or disabled), the OS will consider that there is nothing to be done.
    p The running program will not be notified of unhandled events occurring.

  section
    h1 Example
    p &rarr; Programmatical version of <em>Greeting</em>

  .section-counter
  section.section
    h1 A Short Introduction<br>to Swift

  section
    h1 Swift
    .side
      ul
        li iOS applications should be programmed using objective C or Swift (since iOS 8)
        li Swift is highly recommended (simpler, faster and better supported from now on)
        li Modern syntax inspired by modern languages
        li Heavily object-oriented
    .side
      ul
        li Developed by Apple and published in 2014
        li Lighter and more elegant syntax
        li Better performance with LLVM compiler
        li Can be tested with playgrounds or read-eval-print loop (REPL)

  section
    h1 General Syntax
    .side
      pre
        code.cpp
          | let a = 10
          | var b: Int = 12
          |
          | b += a
          | let primes = [2, 3, 5, 7, 11, 13]
          |
          | func isPrime(n: Int) -> Bool {
          |   for x in 2 ..< n {
          |     if n % x == 0 {
          |       return false
          |     }
          |   }
          |   return true
          | }
          | var x: Int
          | x = 12
          |
          | if isPrime(x) {
          |   println("\(x) is prime.")
          | } else {
          |   println("\(x) is not prime.")
          | }
    .side
      ul
        li Variables are declared with <code>let</code> (immutable) or <code>var</code> (mutable)
        li Variables are typed but type can be inferred by the compiler
        li Functions are declared with <code>func</code>, arguments and return values are typed

  section
    h1 Optionals
    .side
      pre
        code.swift
          | var a: Int? = 12
          | var b = 10
          |
          | b += a  // error, a could be nil
          | if a != nil {
          |   b += a!  // a is unwrapped
          | }
          |
          | a = nil
          | b = nil  // error
          |
          | if let aValue = a {
          |   // conditional unwrapping
          |   b += aValue
          | }
    .side
      p Swift introduces “optional” versions of all types
      ul
        li An optional type <code>T?</code> represents a value that can be either <code>nil</code> or a value of type <code>T</code>
        li Always make sure an optional is not nil before using its value
        li Optionals can be unwrapped to work with the non <code>nil</code> value

  section
    h1 Object Programming
    .side
      p In a “classical” program
      ul
        li program has variables
        li program calls functions that affect variables
    .side
      p In object-oriented programming
      ul
        li variables contain <em>objects</em>
        li objects contain their own “sub-variables” called <em>properties</em>
        li.skip objects carry their own functions called <em>methods</em>
        li possible to access and modify the properies of each object
        li possible to call a specific object method (each objects does its own work)

  section
    h1 Classes and Instances
    .side
      pre
        code.swift
          | class Person {
          |   var name: String // a property
          |   var age: Int
          |
          |   init(name: String, age: Int) {
          |     self.name = name
          |     self.age = age
          |   }
          |
          |   func greet() {  // a method
          |     print("Hello, \(name)!")
          |   }
          |   func increaseAge(years: Int) {
          |     age += years
          |   }
          |
          |   func ageDifferenceWith(other: Person) -> Int {
          |     return age - other.age
          |   }
          | }
    .side
      ul
        li A class is a general description of how objects should be and behave
        li Classes have properties and methods
        li An instance is a specific object, that matches the description of the class
        li Different instances of the same class can have different values of their properties
  section
    h1 Inheritance
    .side
      pre
        code.swift
          | class Student: Person {
          |   var school: String?
          |   var year: Int?
          |
          |   init(name: String, age: Int, school: String, year: Int){
          |     self.school = school
          |     self.year = year
          |     super.init(name: name, age: age)
          |   }
          |
          |   override init(name: String, age: Int) {
          |     super.init(name: name, age: age)
          |   }
          |
          |   override func greet() {
          |     print("Hi, student \(name)")
          |   }
          |
          |   func classDifferenceWith(other: Student) -> Int? {
          |     if let year = year, oYear = other.year {
          |       return year - oYear
          |     }
          |     return nil
          |   }
          | }
    .side
      ul
        li Classes can be defined as a refinement of an existing one
        ul
          li the existing class is the parent of the new class (child)
          li inherits properties and methods from its parent
        li Methods can be redefined in the child (override)

  section
    h1 Creating Objects
    p To create an object
    ul
      li allocate the necessary memory
      li initialize the object according to the specifications of the class
    p These steps are performed by the <code>init</code> function
    <br>
    p Objects are removed from memory automatically when nothing points to them (see later section)

  section
    h1 Intializers
    .side.center
      img(src="figures/initializers.png" style="width: 100%")
    .side
      p Classes can have more than one initializer
      ul
        li Some are <em>designated</em> initializers, others are <em>convenience</em> initializers
        li Designated initializers must call a designated initializer from the parent class
        li Convenience initializers must call another initializer from the same class (and ultimately a designated initializer)

  section
    h1 Illustration
    p Back to the <em>Greeting</em> app.

  section
    h1 Deinit
    .side
      pre
        code.swift
          | class Player {
          |
          |   var coinsInPurse: Int
          |
          |   init(coins: Int) {
          |     coins = Bank.give(coins)
          |   }
          |
          |   func winCoins(coins: Int) {
          |     coins += Bank.give(coins)
          |   }
          |
          |   deinit {
          |     Bank.get(coins)
          |   }
          | }
    .side
      p When an object is removed from memory, its <code>deinit</code> function is called
      <br>
      p This function should be used to clean up the objects or data owned by the removed object
      <br>
      p <code>deinit</code> is called automatically, and should never be called manually

  .section-counter
  section.section
    h1 Graphical User Interface

  section
    h1 Model View Controller
    .side.center
      img(src="figures/mvc_sketch.jpg" style="width: 100%")
    .side
      p Design pattern, for structuring an application in 3 parts
      ul
        li <em>model</em>&nbsp;: data of the application
        li <em>view</em>&nbsp;: user interface, representation of data from the model
        li <em>controller</em>&nbsp;: management logic (program)

  section
    h1 Model View Controller
    .side.center
      img(src="figures/mvc.png" style="width: 100%")
    .side
      ul
        li Communication protocol between separate parts
        li Internal implementation of parts is independent
        li Better structure, easier to maintain

  section
    h1 Model
    .side
      pre
        code.swift
          | class Player {
          |   var cards: [Card]
          |   var game: Game
          |   var points: Int
          |   var isTurnPlayer: Bool
          |
          |   init(...) {
          |     ...
          |   }
          |
          |   func playCard(card: Card) {
          |     ...
          |   }
          |
          |   func endTurn() {
          |     ...
          |   }
          |
          |   func draw(numberOfCards: Int) {
          |     ...
          |   }
          |
          |   ...
          | }
    .side
      p In iOS, the model is represented by the data object classes
      ul
        li the model can be stored in the terminal memory in different forms (<em>Core Data</em>, archiving, <em>NSUserDefaults</em>)
        li organization of the data structures with classes and attributes

  section
    h1 View
    .side.center
      img(src="figures/UIView.jpg" style="width: 90%")
    .side
      p <em>Cocoa Touch</em> (iOS UI Framework) defines a class <code>UIView</code>
      ul
        li all views should inherit from <code>UIView</code>
        li many subclasses are already defined
        li developers can subclass any existing class to add specific behavior
      br
      p <strong>Note&nbsp;:</strong> the elements added to the Storyboard are subclasses of <code>UIView</code>

  section
    h1 UIView
    .side
      p To create a user interface
      ul
        li create a view hierarchy
        li associate specific code (in the controller) to the possible events that the view elements can react to
        ul
          li using the existing subclasses ensures a uniform experience for the users across apps
    .side
      .only(data-step=0)
        p What is a view&nbsp;?
        ul
          li A rectangle
          ul
            li in which it is possible to draw
            li that reacts to events
            li contained in a window (UIWindow)
      .only
        p View hierarchy
        ul
          li each view is placed in a superview
          li a view can have any number of subviews
          li lower level views are drawn on top of higher level
          ul
            li subviews of a same view are drawn one after the other
            li views can have transparent elements

  section
    h1 Position
    .side
      pre
        code.swift
          | let labelFrame = CGRect(x: 20, y: 50, width: 300, height: 50)
          | let label = UILabel(frame: labelFrame)
          | label.text = "Hello"
          | view.addSubview(label)
          |
          | label.center = CGPoint(x: 170, y: 200)
    .side
      A view is positioned relatively to its parent view&nbsp;:
      ul
        li the <code>frame</code> is a <code>CGRect</code> that defines the position and size of a view relative to its parent
        li the <code>center</code> is a <code>CGPoint</code> that positions the view without changing its size
        li the <code>bounds</code> is a <code>CGRect</code> describing the frame of the view in its own coordinates. Usually origin is <em>(0, 0)</em>

  section
    h1 UIView Hierarchy
    .side
      pre
        code.swift
          | var superview: UIView?
          | var subviews: [UIView]
          | var window: UIWindow?
          |
          | func addSubview(UIView)
          | func bringSubview(toFront: UIView)
          | func sendSubview(toBack: UIView)
          | func removeFromSuperview()
          | func insertSubview(UIView, at: Int)
          | func insertSubview(UIView, aboveSubview: UIView)
          | func insertSubview(UIView, belowSubview: UIView)
          | func exchangeSubview(at: Int, withSubviewAt: Int)
          | func isDescendant(of: UIView) -> Bool
    .side
      ul
        li The UIView class has methods to manipulate the hierarchy
        li The superview owns its subviews

  section
    h1 Example&nbsp;: <em>Dominion</em>
    pre
      code(style='font-size: calc(5 * var(--pt))')
        | GameView
        |   LogView
        |     UITextView
        |   StacksView
        |     KingdomCardsView
        |       StackView (x10)
        |         UIImage (background)
        |         UILabel (cost)
        |         UILabel (remaining)
        |     TreasureCardsView
        |       StackView (x3)
        |         UIImage (background)
        |         UILabel (cost)
        |         UILabel (remaining)
        |     VictoryCardsView
        |       StackView (x4)
        |         UIImage (background)
        |         UILabel (cost)
        |         UILabel (remaining)
        |   PlayerView
        |     ChatView
        |       UITextInput
        |       UITextView
        |     ButtonsView
        |       UILabel (instruction)
        |       UIButton (x3)
        |     HandView
        |       CardView (x3)
        |         UIImage
    img(src="figures/dominion.png" style="position: absolute; width: 65%; right: var(--mm)")

  section
    h1 About the Views
    .side.center
      img(src="figures/coordinates.jpg" style="width: 60%")
    .side
      p Cartesian coordinates system
      ul
        li <em>(0, 0)</em> at the top-left corner
        li coordinates are in points (not pixels)
        li handles screen density differences seamlessly
        ul
          li iPhone/iPod 3.5" (1 to 4)&nbsp;: 320 &times; 480
          li iPhone/iPod 4" (5)&nbsp;: 320 &times; 568
          li iPhone 4.7" (6 to 8)&nbsp;: 375 &times; 667
          li iPhone 5.5" (6+ to 8+)&nbsp;: 414 &times; 736
          li iPhone X&nbsp;: 375 &times; 812
          li iPad/iPad mini&nbsp;: 768 &times; 1024
          li iPad Pro 10.5"&nbsp;: 834 &times; 1112
          li iPad Pro 12.9"&nbsp;: 1024 &times; 1366

  section
    h1 Create a View
    p Create a class that inherits from <code>UIView</code>
    ul
      li If necessary, define the method <code>drawRect</code>
      li If the view must be refreshed, use <code>setNeedsDisplay</code>
    br
    p See example&nbsp;: <em>Multiplication</em>

  section
    h1 UIViewController
    img(src="figures/viewcontroller.png" style="width: calc(100 * var(--mm)); position: absolute; top: calc(15 * var(--mm)); right: 0")
    ul(style="z-index: 1; position: absolute; top: calc(43 * var(--mm)); width: 70%")
      li <em>View controllers</em> are objects that manage a view hierarchy
      li The class <code>UIViewController</code> implements view controllers
      li Each controller has a single main view
      li View controllers are responsible for loading, displaying and releasing the view when needed
      li View controllers also (should) manage the events that take place in the view

  section
    h1 Classes Hierarchy
    .center
      img(src="figures/viewcontrollerhierarchy.png" style="width: 65%")

  section
    h1 View Controller Cycle
    .only(data-step=0)
      p Important methods&nbsp;:
      ul
        li <code>init</code>&nbsp;: initialization of the view controller
        li <code>loadView</code>, <code>viewDidLoad</code>&nbsp;: creation of the view
        li <code>viewWillAppear</code>, <code>viewDidAppear</code>&nbsp;: the view is displayed on screen
        li <code>viewWillDisappear</code>, <code>viewDidDisappear</code>&nbsp;: the view is removed from screen
    .only.center
      img(src="figures/viewcontrollercycle.png" style="height: calc(70 * var(--mm))")

  section
    h1 Kinds of View Controllers
    .side
      p Content view controllers display content
      ul
        li simplest view controller
        li manages one view hierarchy
        li a view hierarchy is usually managed by a single content VC
      br
      p examples&nbsp;: table view controller, most user-made view controllers
    .side
      p Container view controllers arrange content of other view controllers
      ul
        li contains content owned by other view controllers
        li manages a list of other view controllers (children)
      br
      p examples&nbsp;: navigation controller, tab bar controller, split view controller

  section
    h1 Nested Content VC
    .side
      pre
        code.swift
          | let subVC = SomeViewController()
          |
          | addChildViewController(subVC)
          | subVC.didMoveToParentViewController(self)
          | view.addSubview(subVC.view)
    .side
      p Most of the time one content view controller is sufficient
      p It is possible to nest content view controllers when necessary
      ul
        li create the sub controller
        li add it as a child to the main controller
        li notify the child that it has been added to the parent
        li add the child's view to the parent's view

  section
    h1 Navigation Controller
    .center
      img(src="figures/navigation.png" style="width: 65%")

  section
    h1 Tab Bar Controller
    .center
      img(src="figures/tabbar.png" style="width: 65%")

  section
    h1 Split View Controller
    .center
      img(src="figures/splitview.png" style="width: 65%")

  section
    h1 Create a Controller
    .side
      pre
        code.swift
          | var view: UIView!
          | var isViewLoaded: Bool
          |
          | func loadView()
          | func viewDidLoad()
          |
          | func viewWillAppear(Bool)
          | func viewDidAppear(Bool)
          | func viewWillDisappear(Bool)
          | func viewDidDisappear(Bool)
          | func viewWillLayoutSubviews()
          | func viewDidLayoutSubviews()
          | func updateViewConstraints()
          | ...
    .side
      ul
        li Create new class that inherits from <code>UIViewController</code>
        li Override relevant methods to define management of view
        li Define when the controller should be loaded

  section
    h1 Initialization
    p The UIViewController class defines two possible initializers
    ul
      li <code>init(nibName nibName: String?, bundle nibBundle: NSBundle?)</code> is used when creating a new view controller programmatically
      li <code>init(coder aDecoder: NSCoder)</code> is used when the view controller is automatically created by iOS (from a storyboard for instance)
    br
    p <strong>Warning&nbsp;:</strong> The view is not loaded at the initialization of the controller
    ul
      li Accessing view elements will crash the application
      li Initialization of the view should be done in <code>viewDidLoad</code> and <code>viewDidAppear</code>

  section
    h1 Initialization
    ul
      li Simplest way (with empty view)&nbsp;:
        pre
          code.swift
            |  let viewController = UIViewController(nibName: nil, bundle: nil)
      li When subclassing (with empty view)&nbsp;:
        pre
          code.swift
            | class MyViewController: UIViewController {
            |   init() {
            |     super.init(nibName: nil, bundle: nil)
            |   }
            | }
      li If using a <code>Nib</code> file (view is created with Nib contents)&nbsp;:
        pre
          code.swift
            | class MyViewController: UIViewController {
            |   init() {
            |   super.init(nibName: "nameOfNibFile", bundle: nil)
            |   }
            | }
  section
    h1 Example
    p A simple example&nbsp;: <em>Quiz</em>
    p Slightly more complex example&nbsp;: <em>Tabs</em> (<code>UITabBarController</code>)

  section
    h1 Switching Controllers
    .side
      .only(data-step=0)
        pre
          code.swift
            | let vc = MyViewController()
            | UIApplication.sharedApplication().keyWindow!.
            |   rootViewController = vc
      .only
        pre
          code.swift
            | let vc = MyViewController()
            | presentViewController(vc, animated: true, completion: nil)
            | dismissViewControllerAnimated(true, completion: nil)
        br
        p Example&nbsp;: <em>SwitchController</em>
      .only(data-start=2)
        pre
          code.swift
            | // create a navigation controller and its
            | // root controller
            | let vc = ViewController()
            | let nc = UINavigationController(rootViewController: vc)
            | window.rootViewController = nc
            | // create a new controller an push it on top
            | let vc2 = ViewController()
            | navigationController?.pushViewController(vc2, animated: true)
            | // pop the top controller (thus recovering
            | // the previous one)
            | navigationController?.
            |   popViewControllerAnimated(true)
        br
        p Example&nbsp;: <em>Navigation Controller</em>
    .side
      p There are many ways to switch from a view controller to another one (and change the displayed view)
      ul
        li.uncover(data-start=0) changing the root controller of the application window (should be avoided)
        li.uncover presenting a new controller
        li.uncover using a navigation controller
      br
      p.uncover Controller transitions can be defined in the Interface Builder (storyboards)

  .section-counter
  section.section
    h1 Responding to Events

  section
    h1 Touch and Motion
    img(src="figures/events.png" style="width: 45%; position:absolute; top: 40%; right: 1%")
    p There are 4 kinds of basic events to interact with the UI&nbsp;:
    ul
      li touch events
      ul
        li single or multiple touches on the screen tap, double-tap, move, etc.
      li motion events (iOS 3)
      ul
        li detected by the accelerometer<br>and gyroscope
        li shake, rotation, acceleration...
      li Remote control events (iOS 4)
      li Presses events (iOS 9)
    p The class of objects that are prepared to handle such events is <code>UIResponder</code>
    ul
      li Subclasses include <code>UIApplication</code>, <code>UIWindow</code>, <code>UIView</code> and <code>UIViewController</code>

  section
    h1 The Responder Chain
    .side
      img(src="figures/responder_chain.png" style="width: 100%")
    .side
      .only(data-step=0)
        p When an event is detected it is sent to a specific responder
        ul
          li for a touch, the view where it happened
          li for another event, the <em>first responder</em>
      .only
        p The event goes through the responder chain until a responder handles it
        ul
          li from a view to its super view
          li from a top view to its controller
          li from a controller to the super view of its view
          li from the main controller to the window, and the application

  section
    h1 Hit Test
    .side
      img(src="figures/hit_test.png" style="width: 100%")
    .side
      p Returns where a touch occurred
      ul
        li recursive calls to <code>hitTest:withEvent:</code>
        li if the touch is in a view, all its sub views are tested
        li if a touch is out of the bounds of a given view, its subviews are not tested
        li return the lowest view in the hierarchy that contains the point of touch
      br
      p Only the point where the touch started counts

  section
    h1 UIEvent
    .side
      pre
        code.swift
          | var timestamp: NSTimeInterval
          | var type: UIEventType
          | var subtype: UIEventSubtype
          | func allTouches() -> Set<NSObject>?
          | func touchesForView(_ view: UIView) -> Set<NSObject>?
          | func touchesForWindow(_ window: UIWindow) -> Set<NSObject>?
    .side
      p <code>UIEvent</code> is the class of objects created when an event occurs
      ul
        li an UIEvent object has a sub-type (none, motion or possible remote control events)
        li touch events contains a set of <code>UITouch</code> objects
        li all events have a time stamps that corresponds to the time when the event was created

  section
    h1 UIEventSubtype
    pre
      code.swift
        | enum UIEventSubtype : Int {
        |   case None
        |   case MotionShake
        |   case RemoteControlPlay
        |   case RemoteControlPause
        |   case RemoteControlStop
        |   case RemoteControlTogglePlayPause
        |   case RemoteControlNextTrack
        |   case RemoteControlPreviousTrack
        |   case RemoteControlBeginSeekingBackward
        |   case RemoteControlEndSeekingBackward
        |   case RemoteControlBeginSeekingForward
        |   case RemoteControlEndSeekingForward
        | }

  section
    h1 Shake
    p <em>UIKit</em> detects 3 events associated with a shake
    ul
      li <code>motionBegan(_:with:)</code> when a shake motion begins
      li <code>motionEnded(_: ith:)</code> when a shake motion ends
      li <code>motionCancelled(_:with:)</code> when a shake motion is cancelled by another event (app becomes inactive, view disappears, etc.)
      ul
        li clean state after <code>motionBegan</code>
    br
    p The motion for a shake is <code>UIEventSubtypeMotionShake</code>

  section
    h1 Touch
    p There are 4 methods to handle touch events
    ul
      li <code>touchesBegan(_:with:)</code>
      li <code>touchesMoved(_:with:)</code>
      li <code>touchesEnded(_:with:)</code>
      li <code>touchesCancelled(_:with:)</code>
    br
    p The first parameter of each method contains the set of UITouch objects that are relevant to the method (began, moved, ended or cancelled)

  section
    h1 Example
    p Touch events in <em>Bezier</em>

  section
    h1 Gesture Recognizers
    p Some specific gestures can be recognized automatically&nbsp;:
    ul
      li single / multiple tap
      li pinch / zoom
      li rotate
      li swipe
      li pan
      li screen-edge pan
      li long press
    br
    p The class <code>UIGestureRecognizer</code> (and its subclasses) handle such events

  section
    h1 Gesture Recognizers
    .side
      pre
        code.swift
          | let tapRecognizer = UITapGestureRecognizer()
          | tapRecognizer.numberOfTapsRequired = 2
          | tapRecognizer.addTarget(self, action: "handleTap:")
          | tapRecognizer.delegate = self
          | view.addGestureRecognizer(tapRecognizer)
      br
      p Warning&nbsp;: the view must have enabled the user interaction
      br
      pre
        code.swift
          | view.userInteractionEnabled = true
    .side
      p To recognize a gesture&nbsp;:
      ul
        li create a gesture recognizer
        li configure the recognizer
        li add a method as target for the recognizer
        li (optional) set the delegate
        li add the recognizer to a view

  section
    h1 Example
    p Double tap recognizer in <em>Bezier</em>

  .section-counter
  section.section
    h1 Focus on Table Views

  section
    h1 Objective
    .side.center
      img(src="figures/table_view.png" style="width: 65%")
    .side
      p A table view is the standard way to display a list of elements&nbsp;:
      ul
        li Manage large sets of data
        ul
          li many elements
          li structured data
        li Use efficiently the limited screen space

  section
    h1 Examples
    div
      img(src="figures/tabView1.png" style="width: 25%")
      img(src="figures/tabView2.png" style="width: 25%")
      img(src="figures/tabView3.png" style="width: 25%")
      img(src="figures/tabView4.png" style="width: 25%")

  section
    h1 Everything in a Table
    .side
      p Representation of data
      ul
        li One column, many lines (cells)
        li Separate sections
        li Vertical scrolling
        li Efficient memory management
        ul
          li very useful for very large data sets

      br
      p Used by almost all apps
    .side
      ul
        li Table is divided in sections
        li Table can have header and footer
        li Sections can have header and footer
        li Data elements represented by a cell
      br
      p All of these elements are fully customizable views

  section
    h1 MVC Structure
    p Table views are a prime example of MVC
    ul
      li <em>Model :</em> data to fill the table (represented by an app-specific class)
      li <em>View :</em> table view, with a cell per data element
      li <em>Controller :</em> usually a subclass of <code>UIViewController</code>
      ul
        li gets the data from the model to make the cells
        li updates the table view if the model changes
        li reacts to events on the table view and updates the model accordingly (<em>eg.</em> deletion of a cell)
    br
    p The view controller implements functions to act as
    ul
      li <code>UITableViewDataSource</code>
      li <code>UITableViewDelegate</code>

  section
    h1 Data Source
    .side
      pre
        code.swift
          | // methods in UITableViewDataSource
          | tableView(_:cellForRowAt:) (*)
          | numberOfSections(in:)
          | tableView(_:numberOfRowsInSection:) (*)
          | sectionIndexTitles(for:)
          | tableView(_:sectionForSectionIndexTitle:at:)
          | tableView(_:titleForHeaderInSection:)
          | tableView(_:titleForFooterInSection:)
          |
          | (*) required methods
    .side
      p The data source must be able to answer questions such as&nbsp;:
      ul
        li how many sections&nbsp;?
        li how many cells in section 3&nbsp;?
        li what is in the 4th cell of section 2&nbsp;?
        li what is the header for section 1&nbsp;?

  section
    h1 Making a Cell
    ul
      li Implement method <code>tableView(_:cellForRowAt:)</code>
      li Returns a <code>UITableViewCell</code>
      li Argument is an <code>NSIndexPath</code>, that locates a cell by its section and row

  section
    h1 Cell Management
    p Problem&nbsp;:
    ul
      li Table data sources can contain hundreds of (or even much more) objects
      li Scrolling through a table must be seamless and efficient

    br
    p Solution :
    ul
      li Create an efficient cell generating mechanism by reusing existing cells that are out of display

  section
    h1 Reuse Cells
    p Tight memory management
    ul
      li Allocate displayed cells
      li Cells out of display marked as unused (can be released at any time)
      li When displaying new cell
      ul
        li take an allocated cell out of display
        li reuse cell by changing relevant fields only
    p Access to cells should always use this system
    br
    pre
      code.swift
        | func tableView(_: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        |   let cell = tableView.dequeueReusableCellWithIdentifier("normalCell", forIndexPath: indexPath)
        |   cell.textLabel?.text = "new label"
        |   return cell
        | }

  section
    h1 Modification of a Table
    .side
      pre
        code.swift
          | tableView(_:commit:forRowAt:)
          | tableView(_:canEditRowAt:)
          | tableView(_:canMoveRowAt:)
          | tableView(_:moveRowAt:to:)
    .side
      p The user interacts with the table view
      ul
        li insertion of a cell
        li deletion of a cell
        li moving a cell

      br
      p User interaction calls functions from the <code>UITableViewDataSource</code> protocol

      br
      p Controller must make changes to data

  section
    h1 Delegate
    p The table view delegate helps manage other features of the table view
    ul
      li configure rows and sections
      li handle selections of cells
      li editing mode
      li manage headers and footers
      li help reorganizing cells
      li etc.

    br
    p Example : <em>TableViews</em>

  .section-counter
  section.section
    h1 Memory Management

  section
    h1 ARC
    p Swift uses Automatic Reference Counting (ARC) to manage objects in memory
    ul
      li associate a counter to each object in memory
      li count how many properties, constants and variables refer to the object
      li.skip whenever counter reaches 0, the object is removed from memory
      li reference counting only applies to instances of classes (reference types)

    br
    p Most of the time, ARC works fine automatically

  section
    h1 Reference Cycle
    pre
      code.swift
        | class Person {
        |   var apartment: Apartment?
        |   ...
        | }
        | class Apartment {
        |   var tenant: Person?
        |   ...
        | }
        |
        | var john = Person()
        | var apt = Apartment()
        | john.apartment = apt
        | apt.tenant = john
        | john = nil
        | apt = nil
        | // neither object is deinitialized
    br
    p.uncover <strong>Problem&nbsp;:</strong> sometimes two (or more) objects refer to each other and are not removed from memory

  section
    h1 Reference Cycle
    pre.only(data-step=0)
      code.swift
        | john = Person(...)
        | apt = Apartment(...)
        | &nbsp;
        | &nbsp;
        | &nbsp;
        | &nbsp;
    pre.only
      code.swift
        | john = Person(...)
        | apt = Apartment(...)
        | john.apartment = apt
        | apt.tenant = john
        | &nbsp;
        | &nbsp;
    pre.only
      code.swift
        | john = Person(...)
        | apt = Apartment(...)
        | john.apartment = apt
        | apt.tenant = john
        | john = nil
        | apt = nil
    .center
      img.only(src="figures/arc1.svg" style="width: 80%" data-step=0)
      img.only(src="figures/arc2.svg" style="width: 80%")
      img.only(src="figures/arc3.svg" style="width: 80%")

  section
    h1 Strong, Weak and Unowned
    .side
      pre
        code.swift
          | class A {
          |   var x: Int          // strong
          |   weak var y: Int?    // weak
          |   unowned var z: Int  // unowned
          |   ...
          | }
    .side
      p To break reference cycles, we use <em>weak</em> or <em>unowned</em> references
      ul
        li <em>weak</em> references for optional types
        ul
          li reference counter is not incremented
          li if referenced object is deinitialized, it is replaced by <code>nil</code>
        li <em>unowned</em> references for other types
        ul
          li does not increment counter
          li should always have a value
          li causes error if accessed after deinitialization

  section
    h1 Breaking the Cycle
    .center
      pre.only(data-step=0)
        code.swift
          | john = Person(...)                  class Apartment {
          | apt = Apartment(...)                  weak var tenant: Person?
          | john.apartment = apt                  ...
          | apt.tenant = john                   }
          | &nbsp;
          | &nbsp;
      pre.only
        code.swift
          | john = Person(...)                  class Apartment {
          | apt = Apartment(...)                  weak var tenant: Person?
          | john.apartment = apt                  ...
          | apt.tenant = john                   }
          | apt = nil
          | &nbsp;
      pre.only(data-start=2)
        code.swift
          | john = Person(...)                  class Apartment {
          | apt = Apartment(...)                  weak var tenant: Person?
          | john.apartment = apt                  ...
          | apt.tenant = john                   }
          | apt = nil
          | john = nil
    .center
      img.only(src="figures/arc4.svg" style="width: 80%" data-step=0)
      img.only(src="figures/arc5.svg" style="width: 80%")
      img.only(src="figures/arc6.svg" style="width: 80%")
      img.only(src="figures/arc7.svg" style="width: 80%")

  section
    h1 Illustration
    p <em>Automatic Reference Counting</em> in a Playground

  .section-counter
  section.section
    h1 Other Interesting<br>Things

  section
    h1 Device Motion
    img(src="figures/axes.png" style="position: absolute; right: 5%; top: 35%; width: 35%")
    p The iDevices contain motion detectors that can measure
    ul
      li acceleration
      li rotation
      li magnetic fields
      li altitude

    br
    p <em>CoreMotion</em> framework
    p Main class is <code>CMMotionManager</code>

  section
    h1 Device Motion
    .side
      p To react to motion
      ul
        li instantiate a <code>CMMotionManager</code> object
        li configure the motion manager
        li (optional) define a handler for measure updates
        li start updates for the desired measure
        li stop updates when not needed
    .side
      p <code>CoreMotion</code> is independent from <code>UIKit</code>
      ul
        li No events, no responder chain
        li Everything goes through the motion manager

      br
      p data can be
      ul
        li pulled&nbsp;: app queries the manager when needed
        li pushed&nbsp;: manager sends updates automatically to the handler
      p Cannot be tested on simulator

  section
    h1 Geolocation
    img(src="figures/maps.png" style="position: absolute; right: 2%; top: 20%; width: 30%")
    div(style="width: 70%")
      p iOS devices can track geographic location
      ul
        li using GPS technology, Wi-Fi or cellular networks
        li compute current latitude and longitude of device
        li can obtain orientation (compass) for devices with magnetometer
        li interface with <code>MapKit</code> for displaying geographic information
      br
      p <em>CoreLocation</em> framework
      p use <code>CLLocationManager</code> class

  section
    h1 Geolocation
    .side
      p Similar to motion events
      ul
        li instantiate <code>CLLocationManager</code>
        li configure manager
        li set <em>delegate</em>
        li start recording location
        li set handler for location update
        li stop recording when not needed

      br
      p See <code>CLLocationManagerDelegate</code> protocol for possible interaction with the manager
    .side
      p Using location services requires user authorization
      ul
        li ask for authorization on first use
        li two levels of authorization : foreground only or foreground and background

      br
      ul
        li Possible to define regions and react to user entering/leaving these regions
        li Significant location change service saves battery by sending updates only when location changes significantly

  section
    h1 Notification Center
    p <strong>Idea&nbsp;:</strong> broadcast information between elements across your app
    ul
      li Works as a bulletin board
      li Any function can post notifications to notification center
      li Any object can observe for a specific notification
      li When notification is sent, all observers are notified and execute a call-back

    br
    p Part of the <em>Foundation</em> framework
    p Use <code>NotificationCenter</code> class and related elements

  section
    h1 Notification Center
    .side
      p Default notification center&nbsp;: <code>NotificationCenter.default</code>
      br
      p Many notifications already defined by API
    .side
      p Notification has
      ul
        li name (<code>Notification.Name</code>)
        li sending object (<code>AnyObject</code>)
        li optional dictionary for more data
      br
      ul
        li Observers can register for notifications by name and/or sender
        li Notification call-backs can be run on separate thread

  section
    h1 Notification Center (Example)
    pre
      code.swift
        | // declare a new notification name
        | extension Notification.Name {
        |   static let specialEvent = Notification.Name("Special Event")
        | }
        |
        | // post a new notification
        | NotificationCenter.default.post(
        |   name: .specialEvent,
        |   object: self,
        |   userInfo: nil)
        |
        | // register to a given notification
        | NotificationCenter.default.addObserver(
        |   self,
        |   selector: #selector(specialAction(notification:)),
        |   name: .specialEvent,
        |   object: nil)
        |
        | // setup a handler
        | func specialAction(notification: NSNotification) {
        |   println("A special event occurred!")
        | }

  section
    h1 Grand Central Dispatch
    p Sometimes, some tasks should be executed asynchronously (in parallel)
    ul
      li long computations that shouldn't slow down UI
      li wait for a special event (ex: semaphore)
      li run tasks in parallel
    br
    p Tasks are organized in queues
    ul
      li Different queues can have different priorities and properties
      li Implements threads
    br
    p Part of the <em>Foundation</em> framework
    p The whole set of functions is denoted as <em>Grand Central Dispatch</em> (GCD)

  section
    h1 Grand Central Dispatch
    .side
      p To dispatch an asynchronous task
      ul
        li get or create queue
        li call <code>async</code> on the queue with code to be executed
    .side
      .only(data-step=0)
        p Queues can be
        ul
          li <em>serial&nbsp;:</em> tasks are run one after the other
          li <em>concurrent&nbsp;:</em> tasks execute in parallel
      .only
        p Some queues are already defined
        ul
          li <em>main queue</em> (serial)&nbsp;: created when app starts. Only queue that should modify the UI
          li <em>global</em> (concurrent) queues&nbsp;:
          ul
            li <code>userInteractive</code>
            li <code>userInitiated</code>
            li <code>default</code>
            li <code>utility</code>
            li <code>background</code>
            li <code>unspecified</code>

  section
    h1 Grand Central Dispatch (Example)
    pre
      code.swift
        | // create a queue
        | let queue = DispatchQueue(label: "uniqueID")
        | let queue = DispatchQueue(label: "uniqueID", qos: .userInitiated)
        | // use existing
        | let bgQueue = DispatchQueue.global(qos: .global)
        | let mainQueue = DispatchQueue.main
        |
        | // dispatch to queue
        | queue.async {
        |   // some code
        | }
        |
        | // background task with UI action
        | bgQueue.async {
        |   // do some complicated task in the background
        |   DispatchQueue.main.async {
        |     // do a simple task on the UI when the previous task
        |     // finishes
        |   }
        | }

  section
    h1 Persisting Data
    p There are many options available to store persistent data on an iDevice
    ul
      li <code>UserDefaults</code>&nbsp;: simplest solution, stores simple information
      li <code>NSCoding</code>&nbsp;: intermediate solution, stores complex objects to file
      li <code>CoreData</code>&nbsp;: most complete solution, stores objects to a database
      li other solutions&nbsp;: saving on iCloud or online server

  section
    h1 UserDefaults
    .side
      p To read or write values&nbsp;:
      ul
        li get a reference to the shared instance <code>UserDefaults.standard</code>
        li get or set values for a given key
    .side
      p Associate values to keys (Strings)
      p Usually used for storing default values or user preferences
      br
      p Can store
      ul
        li <code>Data</code>
        li <code>String</code>
        li <code>Number</code>
        li <code>Date</code>
        li <code>Array</code>
        li <code>Dictionary</code>
      br
      p Very simple to use, but limited

  section
    h1 NSUserDefaults (Example)
    pre
      code.swift
        | // get a reference to the UserDefaults
        | let defaults = UserDefaults.standard
        |
        | // set the value for key "userNameKey"
        | defaults.set("Guybrush Threepwood", forKey: "userNameKey")
        |
        | // get the value for key "userNameKey"
        | let name = defaults.string(forKey: "userNameKey")
        | println(name!)

  section
    h1 CoreData vs. NSCoding
    table.only(data-step=0)
      tr
        th
        th CoreData
        th NSCoding
      tr
        td Entity Modeling
        td Yes
        td No
      tr
        td Querying
        td Yes
        td No
      tr
        td Speed
        td Fast
        td Slow
      tr
        td Serialization Format
        td SQLite, XML, or NSData
        td NSData
      tr
        td Migrations
        td Automatic
        td Manual
      tr
        td Undo Manager
        td Automatic
        td Manual
    table.only
      tr
        th
        th CoreData
        th NSCoding
      tr
        td Persists State
        td Yes
        td Yes
      tr
        td Pain in the Ass
        td Yes
        td No

  section
    h1 NSCoding
    p The NSCoding protocol requires two methods
    ul
      li <code>encode(with coder: NSCoder)</code> describes how to convert the object into an <code>NSData</code> object (byte sequence)
      li <code>init(coder decoder: NSCoder)</code> describes how to create the object from an <code>NSData</code> object
    br
    p Classes <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code> perform the conversions
    br
    It works if all archived properties also conform to <code>NSCoding</code>

  section
    h1 NSCoding
    pre.only(data-step=0)
      code.swift
        | // define a class and describe how to archive/unarchive it
        | class Person: NSObject, NSCoding {
        |   let name: String
        |   let age: Int
        |   init(name: String, age: Int) {
        |     self.name = name
        |     self.age = age
        |   }
        |   required init?(coder decoder: NSCoder) {
        |     self.name = decoder.decodeObject(forKey: "name") as! String
        |     self.age = decoder.decodeInteger(forKey: "age")
        |   }
        |
        |   func encode(with coder: NSCoder) {
        |     coder.encode(name, forKey: "name")
        |     coder.encode(age, forKey: "age")
        |   }
        | }
    pre.only
      code.swift
        | var people = [Person]()
        | people.append(Person(name: "Sherlock Holmes", age: 25))
        | people.append(Person(name: "Mycroft Holmes", age: 32))
        |
        | // encode objects and save data
        | let encodedData = NSKeyedArchiver.archivedData(withRootObject: people)
        | UserDefaults.standard.set(encodedData, forKey: "people")
        |
        | // retrieve data and decode into objects
        | let data = UserDefaults.standard.data(forKey: "people")!
        | let myPeopleList = NSKeyedUnarchiver.unarchiveObject(with: data) as! [Person]

  section
    h1 NSCoding Example
    p Saving the cards list in the <em>TableViews</em> app.

  section
    h1 2D Graphics
    p There are two main options for managing and animating 2D objects
    ul
      li <em>CoreAnimation</em> framework
      ul
        li basic animation on most view properties (position, size, color, etc.)
        li drawing methods on view using layers
      li <em>SpriteKit</em> framework
      ul
        li sprite and image management
        li animations and sequences of actions (combines transformations and events on view elements)
        li 2D physics engine available (collision detection, gravity, inertia, etc.)
    br
    p You could also redo everything by hand on <code>UIView</code> by redefining <code>drawRect</code>...

  section
    h1 3D Graphics
    p Possible options for 3D graphics and animations&nbsp;:
    ul
      li <em>SceneKit</em>&nbsp;: 3D equivalent to <em>SpriteKit</em>, with scenes, objects, animations and physics engine
      li <em>OpenGL ES</em>&nbsp;: platform-neutral API implemented for iOS
      li <em>Metal</em>&nbsp;: Apple specific low-level 3D instructions set

  section
    h1 Bibliography
    ul
      li
        a(href="https://developer.apple.com/library/ios/navigation/") Apple iOS Developer Library
      li
        a(href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language") The Swift Programming Language
      li XCODE Documentation
      li
        a(href="http://stackoverflow.com") StackOverflow
        |  forums (look for "iOS" and/or "Swift" tags)
      li
        a(href="http://nshipster.com") NSHipster
        |  (blog about aspects of iOS/Mac OS X programming)
      li Many tutorials on the web (use your favorite web search engine)
