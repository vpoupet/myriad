<!DOCTYPE html>
<html lang="fr"><head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="stylesheet" href="../css/myriad.css">
    <link rel="stylesheet" href="../css/highlight.css">
    <title>M2101 - Architecture et programmation bas niveau</title>
</head>
<body>


<article class="title" id="slide0">
    <h1>Cours n° 5 :<br>Processus légers<br>(threads)</h1>
    <div class="context">M2101 - Architecture et programmation bas niveau</div>
    <div class="author">Victor Poupet</div>
    <div class="date">12 mars 2018</div>
<a href="#slide-1" class="prev_link"></a><a href="#slide1" class="next_link"></a></article>


<article class="single" id="slide1">
    <h1>Processus légers</h1>
    <p>Si l'on veut exécuter plusieurs tâches en parallèle, on peut utiliser des processus différents</p>
    <ul>
        <li>la création d'un processus est une opération coûteuse
        </li><li>chaque processus occupe un segment de mémoire séparée
        </li><li>le code à exécuter est copié dans chaque nouveau processus
        </li><li>la communication entre processus est difficile (tubes, fichiers, sockets, etc.)
    </li></ul>

    <br>
    <p>Pour exécuter plusieurs instances de la même tâche en parallèle, on peut utiliser des <em>threads</em>
        (processus légers) à la place des processus</p>
    <ul>
        <li>Un unique processus peut exécuter plusieurs threads
        </li><li>L'ordonnancement gère les threads d'un même processus comme des tâches séparées (potentiellement sur des
        processeurs différents)
        </li><li>Les threads sont terminés lorsque le processus termine
    </li></ul>
<div class="page_count">1 / 10</div><a href="#slide0" class="prev_link"></a><a href="#slide2" class="next_link"></a></article>


<article class="split" id="slide2">
    <h1>Processus légers</h1>
    <div class="leftside">
        <div class="center">
            <img src="cours05/cours05-thread-01.svg" style="width: 80%" class="only" data-step="0" alt="threads" data-start="0" data-end="0">
            
        </div>
    </div>
    <div class="rightside">
        <ul>
            <li>Chaque thread a ses propres variables locales, mais elles sont toutes dans la pile du processus
                (un thread a donc accès à la pile des autres)
            </li><li>Les threads d'un processus partagent les segments <code>text</code> et <code>data</code> du processus,
            ainsi que le tas
            </li><li>Chaque thread a ses propres pointeurs de pile et d'exécution, ainsi que l'état des registres du
            processeur
        </li></ul>
    </div>
<div class="page_count">2 / 10</div><a href="#slide1" class="prev_link"></a><a href="#slide3" class="next_link"></a></article><article class="split" id="slide3">
    <h1>Processus légers</h1>
    <div class="leftside">
        <div class="center">
            
            <img src="cours05/cours05-thread-02.svg" style="width: 80%" class="only" alt="threads" data-start="1" data-end="1">
        </div>
    </div>
    <div class="rightside">
        <ul>
            <li>Chaque thread a ses propres variables locales, mais elles sont toutes dans la pile du processus
                (un thread a donc accès à la pile des autres)
            </li><li>Les threads d'un processus partagent les segments <code>text</code> et <code>data</code> du processus,
            ainsi que le tas
            </li><li>Chaque thread a ses propres pointeurs de pile et d'exécution, ainsi que l'état des registres du
            processeur
        </li></ul>
    </div>
<div class="page_count">2 / 10</div><a href="#slide2" class="prev_link"></a><a href="#slide4" class="next_link"></a></article>


<article class="split" id="slide4">
    <h1>En C</h1>
    <div class="leftside">
        <pre><code class="cpp hljs">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> *thread, <span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *attr, <span class="hljs-keyword">void</span> *(*start_routine)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *arg)</span>

<span class="hljs-keyword">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">void</span> **value_ptr)</span>

<span class="hljs-keyword">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *value_ptr)</span>
        </span></code></pre>
    </div>
    <div class="rightside">
        La bibliothèque <code>pthread</code> permet de créer et gérer des threads dans un processus
        <ul>
            <li><code>pthread_create</code> pour démarrer un nouveau thread
                <ul>
                    <li><code>start_routine</code> est la fonction à exécuter dans le thread
                    </li><li>cette fonction prend un unique argument <code>arg</code> de type <code>void*</code>
                </li></ul>
            </li><li><code>pthread_join</code> pour attendre la fin d'un thread en cours
                <ul>
                    <li><code>value_ptr</code> est un pointeur où écrire le résultat de la fonction du thread qui a terminé
                </li></ul>
            </li><li><code>pthread_exit</code> permet de terminer un thread (appelée automatiquement si la fonction <code>start_routine</code> termine)
        </li></ul>
    </div>
<div class="page_count">3 / 10</div><a href="#slide3" class="prev_link"></a><a href="#slide5" class="next_link"></a></article>


<article class="split" id="slide5">
    <h1>Exemple</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-step="0" data-start="0" data-end="0">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NB_CASES 1000</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tab)</span> </span>{
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_CASES; i++) {
    tab[i]=i*i;
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        <pre><code class="cpp only hljs" data-step="0" data-start="0" data-end="0"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> i, tab[NB_CASES];

  tache(tab);

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_CASES; i++) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tab[i]);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    </div>
<div class="page_count">4 / 10</div><a href="#slide4" class="prev_link"></a><a href="#slide6" class="next_link"></a></article><article class="split" id="slide6">
    <h1>Exemple</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="1" data-end="1">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NB_CASES 1000</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NB_THREADS 4</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> debut, <span class="hljs-keyword">int</span> fin, <span class="hljs-keyword">int</span> *tab)</span> </span>{
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">for</span> (i = debut; i &lt; fin; i++) {
    tab[i]=i*i;
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        <pre><code class="cpp only hljs" data-start="1" data-end="1"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> i, tab[NB_CASES];

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_THREADS; i++) {
    debut = i * NB_CASES / NB_THREADS;
    fin = (i+<span class="hljs-number">1</span>) * NB_CASES / NB_THREADS;
    tache(debut, fin, tab);
  }

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_CASES; i++) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tab[i]);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    </div>
<div class="page_count">4 / 10</div><a href="#slide5" class="prev_link"></a><a href="#slide7" class="next_link"></a></article><article class="split" id="slide7">
    <h1>Exemple</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="2" data-end="2">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NB_CASES 1000</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NB_THREADS 4</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadArgs</span> {</span>
  <span class="hljs-keyword">int</span> debut;
  <span class="hljs-keyword">int</span> fin;
  <span class="hljs-keyword">int</span> *tab;
};

<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">tache</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* args)</span> </span>{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadArgs</span> *<span class="hljs-title">a</span> = <span class="hljs-title">args</span>;</span>
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-keyword">for</span> (i = a-&gt;debut; i &lt; a-&gt;fin; i++) {
    a-&gt;tab[i]=i*i;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
        </code></pre>
    </div>
    <div class="rightside">
        <pre><code class="cpp only hljs" data-start="2" data-end="2"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> i, tab[NB_CASES];
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadArgs</span> <span class="hljs-title">args</span>[<span class="hljs-title">NB_THREADS</span>];</span>
  <span class="hljs-keyword">pthread_t</span> threads[NB_THREADS];

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_THREADS; i++) {
    args[i].debut = i * NB_CASES / NB_THREADS;
    args[i].fin = (i+<span class="hljs-number">1</span>) * NB_CASES / NB_THREADS;
    args[i].tab = tab;
    pthread_create(&amp;threads[i], <span class="hljs-literal">NULL</span>, tache, &amp;args[i]);
  }
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_THREADS; i++) {
    pthread_join(threads[i], <span class="hljs-literal">NULL</span>);
  }
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_CASES; i++) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tab[i]);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
    </div>
<div class="page_count">4 / 10</div><a href="#slide6" class="prev_link"></a><a href="#slide8" class="next_link"></a></article>


<article class="split" id="slide8">
    <h1>Concurrence</h1>
    <div class="leftside">
        <pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NB_THREADS 4</span>
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">incr</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> *c = arg;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
        <span class="highlight">(*c)++;</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">int</span> i, <span class="highlight">c</span>;
    <span class="hljs-keyword">pthread_t</span> threads[NB_THREADS];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_THREADS; i++) {
       pthread_create(&amp;threads[i], <span class="hljs-literal">NULL</span>, incr, <span class="highlight">&amp;c</span>); }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NB_THREADS; i++) {
       pthread_join(threads[i], <span class="hljs-literal">NULL</span>);
}
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, c);
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }</code></pre>
    </div>
    <div class="rightside">
        Les threads partagent le même espace mémoire
        <ul>
            <li>La modification d'une variable par un thread affecte les lectures sur cette variable par les autres threads
            </li><li>Problèmes d'accès concurrents
            </li><li>Il faut utiliser des mécanismes complexes pour s'assurer du bon déroulement du programme
            <ul>
                <li>sémaphores
                </li><li>mutex
                </li><li>barrières
            </li></ul>
        </li></ul>
    </div>
<div class="page_count">5 / 10</div><a href="#slide7" class="prev_link"></a><a href="#slide9" class="next_link"></a></article>


<article class="split" id="slide9">
    <h1>Thread safety</h1>
    <div class="leftside">
        <pre><code class="cpp hljs">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">incr</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">pthread_mutex_t</span> mutex;
    mutex = PTHREAD_MUTEX_INITIALIZER;

    <span class="hljs-comment">// bloquer le verrou</span>
    pthread_mutex_lock(&amp;mutex);

    c++;
    <span class="hljs-keyword">int</span> r = c; <span class="hljs-comment">// sauvegarder résultat</span>

    <span class="hljs-comment">// libérer le verrou</span>
    pthread_mutex_unlock(&amp;mutex);

    <span class="hljs-keyword">return</span> r;
}
        </code></pre>
    </div>
    <div class="rightside">
        <ul>
            <li>assurer que les sections critiques (manipulations des variables partagées) ne soient accessibles que
                par un thread
            </li><li>attention aux blocages potentiels
            </li><li>difficile à tester (certains effets se produisent rarement)
            </li><li>les verrouillages ralentissent le parallélisme (goulot d'étranglement)
        </li></ul>
    </div>
<div class="page_count">6 / 10</div><a href="#slide8" class="prev_link"></a><a href="#slide10" class="next_link"></a></article>


<article class="split" id="slide10">
    <h1>Réentrance</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-step="0" data-start="0" data-end="0">
<span class="hljs-comment">// cette fonction est réentrante</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span> </span>{
    <span class="hljs-keyword">int</span> t;
    t = *x;
    *x = *y;
    *y = t;
}
        </code></pre>
    </div>
    <div class="rightside">
        Une fonction est dite <em>réentrante</em> si elle se comporte correctement lorsqu'elle est appelée pendant une
        exécution d'elle-même
        <ul>
            <li>récursivité
            </li><li>exécution lors d'une interruption
            </li><li>exécution concurrente (threads)
        </li></ul>
    </div>
<div class="page_count">7 / 10</div><a href="#slide9" class="prev_link"></a><a href="#slide11" class="next_link"></a></article><article class="split" id="slide11">
    <h1>Réentrance</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="1" data-end="1">
<span class="hljs-keyword">int</span> t;

<span class="hljs-comment">// cette fonction n'est pas réentrante</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span> </span>{
    t = *x;
    *x = *y;
    *y = t;
}
        </code></pre>
    </div>
    <div class="rightside">
        Une fonction est dite <em>réentrante</em> si elle se comporte correctement lorsqu'elle est appelée pendant une
        exécution d'elle-même
        <ul>
            <li>récursivité
            </li><li>exécution lors d'une interruption
            </li><li>exécution concurrente (threads)
        </li></ul>
    </div>
<div class="page_count">7 / 10</div><a href="#slide10" class="prev_link"></a><a href="#slide12" class="next_link"></a></article><article class="split" id="slide12">
    <h1>Réentrance</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="2" data-end="2">
<span class="hljs-keyword">int</span> t;

<span class="hljs-comment">// cette fonction est réentrante</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span> </span>{
    <span class="hljs-keyword">int</span> s = t;
    t = *x;
    *x = *y;
    *y = t;
    t = s;
}
        </code></pre>
    </div>
    <div class="rightside">
        Une fonction est dite <em>réentrante</em> si elle se comporte correctement lorsqu'elle est appelée pendant une
        exécution d'elle-même
        <ul>
            <li>récursivité
            </li><li>exécution lors d'une interruption
            </li><li>exécution concurrente (threads)
        </li></ul>
    </div>
<div class="page_count">7 / 10</div><a href="#slide11" class="prev_link"></a><a href="#slide13" class="next_link"></a></article>


<article class="split" id="slide13">
    <h1>Compilation</h1>
    <div class="leftside">
        <pre><code class="only hljs" data-step="0" data-start="0" data-end="0">$ gcc prog.c -lpthread -D_REENTRANT</code></pre>
    </div>
    <div class="rightside">
        <ul class="only" data-step="0" data-start="0" data-end="0">
            <li>Pour utiliser les fonctions de la bibliothèque <code>pthread</code>, il faut demander au compilateur
                de lier l'exécutable à la bibliothèque&nbsp;: <code>-lpthread</code>
            </li><li>Par ailleurs, il faut indiquer que les fonctions doivent être réentrantes&nbsp;:
            <code>-D_REENTRANT</code>
            <ul>
                <li>certaines fonctions ont des variantes réentrantes (ex : <code>strtok_r</code> au lieu de
                    <code>strtok</code>)
                </li><li>certaines macros sont remplacées par des fonctions (ex : <code>getc</code> et <code>putc</code>)
                </li><li>chaque thread dispose d'une instance différente de la variable <code>errno</code>
            </li></ul>
        </li></ul>
        
    </div>
<div class="page_count">8 / 10</div><a href="#slide12" class="prev_link"></a><a href="#slide14" class="next_link"></a></article><article class="split" id="slide14">
    <h1>Compilation</h1>
    <div class="leftside">
        <pre><code class="only hljs" data-start="1" data-end="1">$ gcc prog.c -pthread</code></pre>
    </div>
    <div class="rightside">
        
        <ul class="only" data-start="1">
            <li>Lorsqu'elle est disponible, l'option <code>-pthread</code> se charge d'activer les options nécessaires,
                spécifiques au système courant (c'est la solution à préférer)
            </li><li>la plupart du temps, cela correspond à<br><code>-lpthread -D_REENTRANT</code>
        </li></ul>
    </div>
<div class="page_count">8 / 10</div><a href="#slide13" class="prev_link"></a><a href="#slide15" class="next_link"></a></article>


<article class="split" id="slide15">
    <h1>Processus Thread</h1>
    <div class="leftside">
        <ul>
            <li>Espace de mémoire virtuelle (apparaît comme connexe) séparée
            </li><li>Identifiant unique au niveau OS
            </li><li>Les processus sont disjoints
            </li><li>Peuvent fonctionner sur des machines distinctes
        </li></ul>
    </div>
    <div class="rightside">
        <ul>
            <li>Subdivision d'un processus</li>
            <li>Mémoire partagée (même espace d'adressage virtuel)</li>
            <li>Sur la même machine (potentiellement sur des processeurs différents)</li>
            <li>Plus simple à créer</li>
            <li>Tous les threads d'un même processus ont le même code</li>
        </ul>
    </div>
<div class="page_count">9 / 10</div><a href="#slide14" class="prev_link"></a><a href="#slide16" class="next_link"></a></article>



<article class="split" id="slide16">
    <h1>Virtualisation</h1>
    <div class="leftside">
        <img src="cours05/cours05-memoireVirtuelle.svg" style="width: 80%" alt="mémoire virtuelle">
    </div>
    <div class="rightside">
        Les processus n'ont pas directement accès aux différentes mémoires physiques
        <ul>
            <li>Ils disposent d'un espace de mémoire virtuelle
            </li><li>L'unité de gestion de mémoire (MMU) s'occupe de la correspondance
            </li><li>Permet d'isoler les processus
            </li><li>Masque les problèmes de fragmentation (le noyau s'en occupe)
        </li></ul>
    </div>
<div class="page_count">10 / 10</div><a href="#slide15" class="prev_link"></a><a href="#slide17" class="next_link"></a></article>






</body></html>
