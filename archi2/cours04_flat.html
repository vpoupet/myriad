<!DOCTYPE html>
<html lang="fr"><head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="../css/slides.css">
    <link rel="stylesheet" href="../css/myriad.css">
    <link rel="stylesheet" href="../css/highlight.css">
    <title>M2101 - Architecture et programmation bas niveau</title>
</head>
<body>


<a id="slide_anchor0"></a><section class="title">
    <h1>Cours n° 4 :<br>Création de processus</h1>
    <div class="context">M2101 - Architecture et programmation bas niveau</div>
    <div class="author">Victor Poupet</div>
    <time datetime="2018-03-05">5 mars 2018</time>
<div class="slide_footer"><div class="page_counter">0 / 10</div></div><a href="#slide_anchor-1" class="prev_flat_link"></a><a href="#slide_anchor1" class="next_flat_link"></a></section>


<a id="slide_anchor1"></a><section class="split">
    <h1>Hiérarchie de processus</h1>
    <div class="leftside">
        <pre><code class="hljs">$ ps ax

  PID  PPID S COMMAND
<span class="highlight">    1     0 S /sbin/init</span>
  338     1 S /sbin/udevd --daemon
  481   338 S /sbin/udevd --daemon
 1200   880 S lightdm --session-child
 1301  1200 S gnome-session
 1528     1 S /usr/lib/gvfs/gvfsd
 1532  1301 S nm-applet
 1556  1301 S /usr/lib/gnome-settings
 1590     1 S /usr/lib/gvfs/gvfs-gdu
 1627     1 S /usr/lib/bamf/bamfdaemon
 1636  1635 S /usr/bin/gtk-window
 1639     1 S /usr/lib/unity/unity
 1845     1 S /usr/lib/gnome-online
 <span class="highlight">1853     1</span> R gnome-terminal
 2414     1 S /usr/lib/dconf/dconf
 <span class="highlight">2431  1853</span> S bash
 <span class="highlight">2597  2431</span> R ps ax</code></pre>
    </div>
    <div class="rightside">
        Au démarrage de l'ordinateur, le processus <code>init</code> est lancé
        <ul>
            <li>Par la suite, tous les autres processus sont démarrés par un processus existant (parent)
            </li><li>Chaque processus est identifié par un numéro unique (PID) et connaît le numéro de son parent (PPID)
            </li><li>La commande <code>ps</code> permet d'obtenir le PID et le PPID d'un processus
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">1 / 10</div></div><a href="#slide_anchor0" class="prev_flat_link"></a><a href="#slide_anchor2" class="next_flat_link"></a></section>


<a id="slide_anchor2"></a><section class="single">
    <h1>Hiérarchie (pstree)</h1>
    <div>
        <pre><code class="hljs">
$ <span class="highlight">pstree -p</span>

<span class="highlight">init(1)</span>─┬─NetworkManager(793)─┬─dhclient(911)
        │                     └─dnsmasq(1012)
        ├─accounts-daemon(1214)───{accounts-daemon}(1215)
        ├─cron(855)
        ├─cupsd(729)───dbus(3916)
        ├─dconf-service(1997)─┬─{dconf-service}(1998)
        │                     └─{dconf-service}(2000)
        ├─gnome-keyring-d(1407)─┬─{gnome-keyring-d}(1408)
        │                       └─{gnome-keyring-d}(1970)
        ├─<span class="highlight">gnome-terminal(1737)</span>─┬─<span class="highlight">bash(1746)</span>───<span class="highlight">pstree(20545)</span>
        │                      ├─gnome-pty-helpe(1745)
        │                      └─{gnome-terminal}(1747)
        ├─goa-daemon(1895)───{goa-daemon}(1911)
        ├─gvfs-afc-volume(1612)───{gvfs-afc-volume}(1614)
        ├─mission-control(1890)─┬─{mission-control}(1893)
        │                       └─{mission-control}(1909)
        ├─sh(884)───initctl(886)
        └─udisks-daemon(1604)───udisks-daemon(1609)
        </code></pre>
    </div>
<div class="slide_footer"><div class="page_counter">2 / 10</div></div><a href="#slide_anchor1" class="prev_flat_link"></a><a href="#slide_anchor3" class="next_flat_link"></a></section>


<a id="slide_anchor3"></a><section class="split">
    <h1>Création</h1>
    <div class="leftside">
        <div class="only" data-step="0" data-start="0" data-end="0">
            <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
      <span class="hljs-keyword">pid_t</span> pid = fork();
      <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) {
        perror(<span class="hljs-string">"fork"</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) {
          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"F%d\n"</span>, i);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) {
          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"P%d "</span>, i);
        }
      }
    }</code></pre>
            <hr>
            <pre><code class="cpp hljs">$ ./a.out

    P0 P1 P2 F0 F1 F2</code></pre>
        </div>
        
    </div>
    <div class="rightside">
        Pour créer un nouveau processus, on clone un processus existant à l'aide de l'appel <code>fork()</code>
        <ul>
            <li>Le système copie&nbsp;:
                <ul>
                    <li>la mémoire (pile, tas, code)
                    </li><li>les descripteurs de fichiers ouverts (cependant les pointeurs dans les fichiers sont partagés)
                    </li><li>l'état d'exécution (pointeur d'exécution, registres du processeur)
                </li></ul>
            </li><li>Différences entre les processus&nbsp;:
                <ul>
                    <li>le processus fils a un PID et un PPID différent du père (son PPID est le PID du père)
                    </li><li>la fonction <code>fork</code> renvoie 0 dans le processus fils, et le PID du fils dans le
                    processus père
                </li></ul>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">3 / 10</div></div><a href="#slide_anchor2" class="prev_flat_link"></a><a href="#slide_anchor4" class="next_flat_link"></a></section><a id="slide_anchor4"></a><section class="split">
    <h1>Création</h1>
    <div class="leftside">
        
        <div class="only" data-start="1" data-end="1">
            <pre><code class="cpp hljs"><span class="hljs-comment">// fork bomb !</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) fork();
    }</code></pre>
            <div class="center">
                <img src="cours04/cours04-BobOmb.jpg" style="width: 50%" alt="Bob Omb">
            </div>
        </div>
    </div>
    <div class="rightside">
        Pour créer un nouveau processus, on clone un processus existant à l'aide de l'appel <code>fork()</code>
        <ul>
            <li>Le système copie&nbsp;:
                <ul>
                    <li>la mémoire (pile, tas, code)
                    </li><li>les descripteurs de fichiers ouverts (cependant les pointeurs dans les fichiers sont partagés)
                    </li><li>l'état d'exécution (pointeur d'exécution, registres du processeur)
                </li></ul>
            </li><li>Différences entre les processus&nbsp;:
                <ul>
                    <li>le processus fils a un PID et un PPID différent du père (son PPID est le PID du père)
                    </li><li>la fonction <code>fork</code> renvoie 0 dans le processus fils, et le PID du fils dans le
                    processus père
                </li></ul>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">3 / 10</div></div><a href="#slide_anchor3" class="prev_flat_link"></a><a href="#slide_anchor5" class="next_flat_link"></a></section>


<a id="slide_anchor5"></a><section class="split">
    <h1>Attente de complétion</h1>
    <div class="leftside">
        <pre><code class="hljs">
SYNOPSIS
  #include &lt;sys/types.h&gt;
  #include &lt;/wait.h&gt;

  pid_t wait(int *status);
  pid_t waitpid(pid_t pid, int *status, int options);
        </code></pre>
    </div>
    <div class="rightside">
        Les commandes <code>wait</code> et <code>waitpid</code> demandent à un processus d'attendre que ses
        processus fils changent d'état
        <ul>
            <li>Lorsqu'un fils se termine, la commande <code>wait</code> permet au parent de recevoir le code de
                retour du fils
            </li><li>Le fils est supprimé de la table de processus quand son père reçoit le code de retour
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">4 / 10</div></div><a href="#slide_anchor4" class="prev_flat_link"></a><a href="#slide_anchor6" class="next_flat_link"></a></section>


<a id="slide_anchor6"></a><section class="split">
    <h1>Zombies</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-step="0" data-start="0" data-end="0">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
  <span class="hljs-keyword">pid_t</span> pid;
  pid = fork();
  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) { <span class="hljs-comment">// fils</span>
    sleep(<span class="hljs-number">10</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Fin fils\n"</span>);
  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// père</span>
    sleep(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Fin père\n"</span>);
  }
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
}
        </code></pre>
    <img src="cours04/cours04-zombie.png" style="width: 28%; position: absolute; bottom: 0; left: 27%" alt="Zombie">
    </div>
    <div class="rightside">
        Lorsqu'un processus se termine, il n'est pas immédiatement supprimé de la table
        <ul>
            <li>Le parent doit explicitement le supprimer à l'aide de l'appel <code>wait</code>
            </li><li>Si le processus reste, il devient un <em>zombie</em>
            </li><li>Les processus zombies n'occupent pas de mémoire, mais ils bloquent un PID (et sont souvent le signe d'un bug dans le processus parent)
            </li><li>Si le parent est terminé avant le fils, le fils devient orphelin et est récupéré par <code>init</code> (qui appelle <code>wait</code> régulièrement)
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">5 / 10</div></div><a href="#slide_anchor5" class="prev_flat_link"></a><a href="#slide_anchor7" class="next_flat_link"></a></section><a id="slide_anchor7"></a><section class="split">
    <h1>Zombies</h1>
    <div class="leftside">
        <pre><code class="only hljs" data-start="1" data-end="1">
$ ps
 PID  TTY     STAT   COMMAND
 1859 pts/0   Ss     bash
 2570 pts/0   S      ./prog
 2571 pts/0   Z      <span class="highlight">[prog] &lt;defunct&gt;</span>





        </code></pre>
    <img src="cours04/cours04-zombie.png" style="width: 28%; position: absolute; bottom: 0; left: 27%" alt="Zombie">
    </div>
    <div class="rightside">
        Lorsqu'un processus se termine, il n'est pas immédiatement supprimé de la table
        <ul>
            <li>Le parent doit explicitement le supprimer à l'aide de l'appel <code>wait</code>
            </li><li>Si le processus reste, il devient un <em>zombie</em>
            </li><li>Les processus zombies n'occupent pas de mémoire, mais ils bloquent un PID (et sont souvent le signe d'un bug dans le processus parent)
            </li><li>Si le parent est terminé avant le fils, le fils devient orphelin et est récupéré par <code>init</code> (qui appelle <code>wait</code> régulièrement)
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">5 / 10</div></div><a href="#slide_anchor6" class="prev_flat_link"></a><a href="#slide_anchor8" class="next_flat_link"></a></section>


<a id="slide_anchor8"></a><section class="split">
    <h1>Éviter les zombies</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-step="0" data-start="0" data-end="0">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> pid1;
  pid1 = fork();
  <span class="hljs-keyword">if</span> (pid1) {
    <span class="hljs-comment">// père</span>
    <span class="hljs-comment">/* Tâche principale */</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// fils</span>
    <span class="hljs-comment">/* Tâche secondaire */</span>
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        Parfois, la tâche exécutée par le fils est longue et on ne veut pas bloquer le père en attente de complétion

        <ul>
            <li>On peut mettre en place une gestion de signaux (SIGCHLD)
            </li><li>On peut faire en sorte que le processus fils soit immédiatement adopté par <code>init</code>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">6 / 10</div></div><a href="#slide_anchor7" class="prev_flat_link"></a><a href="#slide_anchor9" class="next_flat_link"></a></section><a id="slide_anchor9"></a><section class="split">
    <h1>Éviter les zombies</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="1" data-end="1">
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> signo)</span> </span>{
  wait(<span class="hljs-literal">NULL</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="highlight">signal(SIGCHLD, handler);</span>
  <span class="hljs-keyword">int</span> pid1;
  pid1 = fork();
  <span class="hljs-keyword">if</span> (pid1) {
    <span class="hljs-comment">// père</span>
    <span class="hljs-comment">/* Tâche principale */</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// fils</span>
    <span class="hljs-comment">/* Tâche secondaire */</span>
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        Parfois, la tâche exécutée par le fils est longue et on ne veut pas bloquer le père en attente de complétion

        <ul>
            <li>On peut mettre en place une gestion de signaux (SIGCHLD)
            </li><li>On peut faire en sorte que le processus fils soit immédiatement adopté par <code>init</code>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">6 / 10</div></div><a href="#slide_anchor8" class="prev_flat_link"></a><a href="#slide_anchor10" class="next_flat_link"></a></section><a id="slide_anchor10"></a><section class="split">
    <h1>Éviter les zombies</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="2" data-end="2">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> pid1, pid2;
  pid1 = fork();
  <span class="hljs-keyword">if</span> (pid1) {
    <span class="hljs-comment">// père</span>
    <span class="highlight">waitpid(pid1, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);</span>
    <span class="hljs-comment">/* Tâche principale */</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// fils</span>
    <span class="highlight">pid2 = fork();</span>
    <span class="hljs-keyword">if</span> (pid2) {
      <span class="hljs-comment">// fils</span>
      <span class="highlight"><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// petit- fils</span>
      <span class="hljs-comment">/* Tâche secondaire */</span>
    }
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        Parfois, la tâche exécutée par le fils est longue et on ne veut pas bloquer le père en attente de complétion

        <ul>
            <li>On peut mettre en place une gestion de signaux (SIGCHLD)
            </li><li>On peut faire en sorte que le processus fils soit immédiatement adopté par <code>init</code>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">6 / 10</div></div><a href="#slide_anchor9" class="prev_flat_link"></a><a href="#slide_anchor11" class="next_flat_link"></a></section>


<a id="slide_anchor11"></a><section class="single">
    <h1>fork</h1>
    <div>
        <p>La fonction <code>fork</code> est appelée par un processus mais renvoie deux résultats, dans deux processus
            distincts</p>
        <ul>
            <li>Le père reçoit le PID du fils
            </li><li>Le fils peut obtenir le PID du père&nbsp;: <code>getppid()</code>
            </li><li>Si le fils et le père doivent avoir des comportements différents, il faut que les deux aient l'ensemble
            du code<span class="uncover hidden" data-start="1">... sauf s'il existe un moyen de changer le code d'un processus</span>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">7 / 10</div></div><a href="#slide_anchor10" class="prev_flat_link"></a><a href="#slide_anchor12" class="next_flat_link"></a></section><a id="slide_anchor12"></a><section class="single">
    <h1>fork</h1>
    <div>
        <p>La fonction <code>fork</code> est appelée par un processus mais renvoie deux résultats, dans deux processus
            distincts</p>
        <ul>
            <li>Le père reçoit le PID du fils
            </li><li>Le fils peut obtenir le PID du père&nbsp;: <code>getppid()</code>
            </li><li>Si le fils et le père doivent avoir des comportements différents, il faut que les deux aient l'ensemble
            du code<span class="uncover" data-start="1">... sauf s'il existe un moyen de changer le code d'un processus</span>
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">7 / 10</div></div><a href="#slide_anchor11" class="prev_flat_link"></a><a href="#slide_anchor13" class="next_flat_link"></a></section>


<a id="slide_anchor13"></a><section class="split">
    <h1>Exécution</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-end="1">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ..., <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> envp[])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;
        </code></pre>
    </div>
    <div class="rightside">
        <div class="only" data-step="0" data-start="0" data-end="0">
            La famille de fonctions exec permet de remplacer le code d'un processus par un autre
            <ul>
                <li>le premier argument est un exécutable
                </li><li>les arguments suivants permettent de passer des paramètres et des variables d'environnement
                </li><li>à l'appel de la fonction, tout le code du processus est remplacé par celui indiqué et l'état du processus est réinitialisé
            </li></ul>
        </div>
        
    </div>
<div class="slide_footer"><div class="page_counter">8 / 10</div></div><a href="#slide_anchor12" class="prev_flat_link"></a><a href="#slide_anchor14" class="next_flat_link"></a></section><a id="slide_anchor14"></a><section class="split">
    <h1>Exécution</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-end="1">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ...)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *arg, ..., <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> envp[])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *file, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[])</span></span>;
        </code></pre>
    </div>
    <div class="rightside">
        
        <div class="only" data-start="1">
            Il existe plusieurs variantes&nbsp;:
            <ul>
                <li><code>l</code> (<em>list</em>)&nbsp;: les arguments sont passés un par un à la fonction, avec un pointeur nul (<code>NULL</code>) en dernier
                </li><li><code>v</code> (<em>vector</em>)&nbsp;: les arguments sont passés dans un unique tableau
                </li><li><code>p</code> (<em>path</em>)&nbsp;: l'exécutable est cherché dans les répertoires du chemin d'exécution
                </li><li><code>e</code> (<em>environment</em>)&nbsp;: permet de passer un tableau contenant des variables d'environnement pour l'exécution du nouveau programme
            </li></ul>
        </div>
    </div>
<div class="slide_footer"><div class="page_counter">8 / 10</div></div><a href="#slide_anchor13" class="prev_flat_link"></a><a href="#slide_anchor15" class="next_flat_link"></a></section><a id="slide_anchor15"></a><section class="split">
    <h1>Exécution</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-step="2" data-start="2" data-end="2">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
  <span class="hljs-keyword">pid_t</span> pid;
  <span class="hljs-keyword">int</span> status;
  pid = fork();
  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
    <span class="highlight">execlp(<span class="hljs-string">"ls"</span>, <span class="hljs-string">"ls"</span>, <span class="hljs-string">"-l"</span>, <span class="hljs-literal">NULL</span>);</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Père \n"</span>);
    wait(&amp;status);
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        
        <div class="only" data-start="1">
            Il existe plusieurs variantes&nbsp;:
            <ul>
                <li><code>l</code> (<em>list</em>)&nbsp;: les arguments sont passés un par un à la fonction, avec un pointeur nul (<code>NULL</code>) en dernier
                </li><li><code>v</code> (<em>vector</em>)&nbsp;: les arguments sont passés dans un unique tableau
                </li><li><code>p</code> (<em>path</em>)&nbsp;: l'exécutable est cherché dans les répertoires du chemin d'exécution
                </li><li><code>e</code> (<em>environment</em>)&nbsp;: permet de passer un tableau contenant des variables d'environnement pour l'exécution du nouveau programme
            </li></ul>
        </div>
    </div>
<div class="slide_footer"><div class="page_counter">8 / 10</div></div><a href="#slide_anchor14" class="prev_flat_link"></a><a href="#slide_anchor16" class="next_flat_link"></a></section><a id="slide_anchor16"></a><section class="split">
    <h1>Exécution</h1>
    <div class="leftside">
        <pre><code class="cpp only hljs" data-start="3" data-end="3">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
  <span class="hljs-keyword">pid_t</span> pid;
  <span class="hljs-keyword">int</span> status;
  pid = fork();
  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">char</span> *args[<span class="hljs-number">3</span>];
    args[<span class="hljs-number">0</span>] = <span class="hljs-string">"ls"</span>;
    args[<span class="hljs-number">1</span>] = <span class="hljs-string">"-l"</span>;
    args[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;
    <span class="highlight">execvp(<span class="hljs-string">"ls"</span>, args);</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Père \n"</span>);
    wait(&amp;status);
  }
}
        </code></pre>
    </div>
    <div class="rightside">
        
        <div class="only" data-start="1">
            Il existe plusieurs variantes&nbsp;:
            <ul>
                <li><code>l</code> (<em>list</em>)&nbsp;: les arguments sont passés un par un à la fonction, avec un pointeur nul (<code>NULL</code>) en dernier
                </li><li><code>v</code> (<em>vector</em>)&nbsp;: les arguments sont passés dans un unique tableau
                </li><li><code>p</code> (<em>path</em>)&nbsp;: l'exécutable est cherché dans les répertoires du chemin d'exécution
                </li><li><code>e</code> (<em>environment</em>)&nbsp;: permet de passer un tableau contenant des variables d'environnement pour l'exécution du nouveau programme
            </li></ul>
        </div>
    </div>
<div class="slide_footer"><div class="page_counter">8 / 10</div></div><a href="#slide_anchor15" class="prev_flat_link"></a><a href="#slide_anchor17" class="next_flat_link"></a></section>


<a id="slide_anchor17"></a><section class="split">
    <h1>Exemple : ls</h1>
    <div class="leftside">
        <div class="center">
            <img src="cours04/cours04-exec.svg" style="width:80%" alt="exec">
        </div>
    </div>
    <div class="rightside">
        Le shell veut exécuter la commande <code>ls</code>
        <ul>
            <li><code>fork()</code> pour créer le processus fils
            </li><li>le père attend que le fils ait fini son exécution (si la commande est en arrière plan le père ne se bloque pas)
            </li><li>le fils appelle <code>exec</code> pour remplacer son code par celui du programme <code>ls</code>
            </li><li>quand le fils termine, le père reçoit le code de retour, supprime le processus fils et reprend son exécution
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">9 / 10</div></div><a href="#slide_anchor16" class="prev_flat_link"></a><a href="#slide_anchor18" class="next_flat_link"></a></section>

<a id="slide_anchor18"></a><section class="single">
    <h1>Copie sur écriture</h1>
    <div>
        <p>L'utilisation de <code>fork</code>/<code>exec</code> est le moyen le plus classique (et parfois le seul disponible)
        pour créer des nouveaux processus</p>
        <ul>
            <li>Si le nouveau processus va être remplacé par un autre programme (<code>exec</code>) il est inutile de
                copier toute sa mémoire au moment du <code>fork</code>
            </li><li>Pour alléger, on utilise souvent une technique appelée <em>copy on write</em>&nbsp;:
                <ul>
                    <li>lorsque le nouveau processus est créé, on ne copie pas sa mémoire
                    </li><li>il dispose de pointeurs vers la mémoire du père pour la lecture
                    </li><li>la mémoire est copiée au moment de la première écriture par le fils
                </li></ul>
            </li><li>Dans le cas où <code>exec</code> suit <code>fork</code>, la mémoire n'est pas copiée
        </li></ul>
    </div>
<div class="slide_footer"><div class="page_counter">10 / 10</div></div><a href="#slide_anchor17" class="prev_flat_link"></a><a href="#slide_anchor19" class="next_flat_link"></a></section>






</body></html>
